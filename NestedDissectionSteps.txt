Nested Dissection CH Plan


Split finder: 
build SeparatorFinder that, given a vertex subset, returns (A, S, B) 
using a balanced partition heuristic (BFS/flow, spectral, or available partitioner); 
include fallback for tiny or failed cuts.

Recursion driver: implement NestedDissectionOrder.buildOrder(Graph g) that calls recurse(subgraphVertices, orderBuilder) 
with a threshold; 
manages temporary ID remapping so induced subgraph edges stay valid.

Base case ordering: inside recurse, when |subgraph| ≤ threshold, feed those vertices to EdgeDiffPriorityQueue (single subgraph copy of the standard CH priority) 
and append popped vertices to the global order.

Subgraph processing: after finding A and B, instantiate fresh EdgeDiffPriorityQueues scoped to A and B (same scoring used in full CH); 
contract vertices in priority order, writing to the global order, and materialize shortcuts only inside the subgraph.

Separator cleanup: once both halves finish, rebuild adjacency for vertices in S, run the same edge-diff queue, contract them, 
and append to the order.

Graph updates: maintain a shared ShortcutBuilder that, whenever a vertex is popped, computes required shortcuts, 
inserts them into the working graph, and updates affected vertices’ edge-diff priorities (lazy decrease-key).

Final permutation: concatenate the recorded contraction order into an int[] permutation, hand it to the existing CH preprocessing pipeline, 
and verify that shortcut counts remain stable (run your usual CH unit/integration tests).